import asyncio
from bleak import BleakClient, discover

SENSOR_VAL_UUID = '00001560-1212-efde-1523-785feabcd123'
PORT_INFO_UUID = '00001527-1212-efde-1523-785feabcd123'
INPUT_COMMAND_UUID = '00001563-1212-efde-1523-785feabcd123'
OUTPUT_COMMAND_UUID = '00001565-1212-efde-1523-785feabcd123'
PORT_NOTIF_UUID = '00001524-1212-efde-1523-785feabcd123'

LED_ABSOLUTE_MODE = 0
LED_DISCREET_MODE = 1

# LED index colors
LED_INDEX_PINK = 0x01
LED_INDEX_PURPLE = 0x02

DIST_DETECT_MODE = 0
DIST_COUNT_MODE = 1

loop = asyncio.get_event_loop()

GLOBAL_Q = []

class HubManager():
	"""docstring for HubManager"""
	def __init__(self, wnum):
		self.wedos = []


		for _ in range(wnum):
			loop.run_until_complete( self.get_wedo() )

	async def get_wedo(self):
		devices = await discover()
		for d in devices:
			mac_addr = str(d).split(' ',1)[0][:-1]
			name = str(d).split(' ',1)[1]
			

			if mac_addr.startswith('24:71:89:') or 'LPF2 Smart Hub' in name:
				print(d)
				client = BleakClient(mac_addr, loop=loop)
				await client.connect()
				self.wedos.append( Smarthub( client ) )

class Smarthub ():
	def __init__(self, client):
		self.client = client
		self.ports = [None] * 2

	def set_led_mode (self, mode):

		async def _():
			await self.client.write_gatt_char(INPUT_COMMAND_UUID, bytearray([0x01,0x02,0x06,0x17,mode,0x01,0x00,0x00,0x00,0x02,0x01]), True)

		loop.run_until_complete(_())

	def set_led_color (self, *args):
		async def _():
			pass


		if len(args) == 1:
			async def _():
				await self.client.write_gatt_char(OUTPUT_COMMAND_UUID, bytearray([0x06,0x04,0x01, args[0] ]), True)
					
		elif len(args) == 3:
			r,g,b = args

			async def _():
				await self.client.write_gatt_char(OUTPUT_COMMAND_UUID, bytearray( [0x06,0x04,0x03,r,g,b] ), True)

		else:
			raise Exception('Incorrect arguments, either pass 1 (index) number or 3 (rgb)')

		loop.run_until_complete(_())

	def attach(self, periph, port, callback=None):
		if isinstance(periph, Attachment):
			periph.client = self.client
			periph.port = port

			self.ports[port-1] = periph

			# if isinstance(periph, Sensor):
			# 	# Notifications
			# 	async def _():
			# 		await self.client.write_gatt_char(PORT_NOTIF_UUID, [0x00, 0x41, port, 0x00, 1, 0, 0, 0, 1])
			# 		await self.client.start_notify(SENSOR_VAL_UUID, 
			# 			lambda sender, data: self.sensor_handler(sender, data, callback) )

			# 	loop.run_until_complete(_())



		else:
			raise Exception('peripheral must be of type Attachment')


	def activate_ports (self, callback):
		for p in self.ports:
			if isinstance(p, Sensor):
				# Notifications
				async def _():
					await self.client.write_gatt_char(PORT_NOTIF_UUID, [0x00, 0x41, self.ports.index(p), 0x00, 1, 0, 0, 0, 1])
					await self.client.start_notify(SENSOR_VAL_UUID, 
						lambda sender, data: self.sensor_handler(sender, data, callback) )

				loop.run_until_complete(_())



	def disconnect(self):
		async def _():
			await self.client.disconnect()

	def sensor_handler(self, sender, data, cb):

		int_values = [x for x in data]

		if len(int_values) < 4:
			return

		x, y = int_values[-2:]

		val = self.convert_to_number(x,y)
		port = int_values[1]

		print(int_values)

		self.ports[port-1].last_value = val

		cb (self, port, val)

	def convert_to_number(self, x, y):
		if x == 0 and y == 0:
			return 0
		if x == 0 and y == 195:
			return 128
		
		offset = (4**(y%128 - 63))/(2 if x < 128 else 1) * (1 + (x%128/128))
		number = offset if y < 128 else 256-offset
		return int(number)


# 								#
#			ATTACHMENTS			# 
# 								#


class Attachment:
	def __init__(self, client=None, port=None):
		self.client = client
		self.port = port

class Sensor(Attachment):
	def __init__ (self, client, port):
		super().__init__(client, port)
		self.last_value = -1

	def read_val (self):
		async def _():
			await client.read_gatt_char(SENSOR_VAL_UUID)

class DistanceSensor(Sensor):
	def set_mode (self, mode, queue=False):
		data = bytearray( [0x01,0x02,self.port,0x23,mode,0x01,0x00,0x00,0x00,0x02,0x01] )

		if queue:
			GLOBAL_Q.append( (self.client, INPUT_COMMAND_UUID, data) )
		else:
			async def _():
				await self.client.write_gatt_char(INPUT_COMMAND_UUID, data, True)

			loop.run_until_complete(_())

class Motor(Attachment):
	
	def set_speed(self, speed, queue=False):
		data = bytearray( [self.port, 0x01, 0x01, self.translate_speed(speed)] )

		if queue:
			GLOBAL_Q.append( (self.client, OUTPUT_COMMAND_UUID, data) )
		else:
			async def _():
				await self.client.write_gatt_char(OUTPUT_COMMAND_UUID, data, True)

			loop.run_until_complete(_())

	def translate_speed(self, speed):
	    if speed < 0:
	        return int((0x54*max(speed,-1))+0xF0)
	    elif speed > 0:
	        return int((0x54*min(speed,1))+0x10)
	    else:
	        return 0x00


def process_q ():
	global GLOBAL_Q
	for q in GLOBAL_Q:
		try:
			# Write
			client, uuid, data = q

			async def _():
				await client.write_gatt_char(uuid, data, True)

			loop.run_until_complete(_())
		except ValueError:
			# Read
			client, uuid = q
			client.read_gatt_char(uuid)

	GLOBAL_Q = []